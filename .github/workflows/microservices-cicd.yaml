name: Microservices CI/CD

on:
  push:
    branches:
      - main
      - dev
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: read
  packages: write

env:
  DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: asia-southeast1-b
  K8S_NAMESPACE: chronoflow

jobs:
  detect-changes:
    name: Detect Changed Services
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.resolve.outputs.services }}
      all-services: ${{ steps.set-services.outputs.all }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed services
        uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            user-service:
              - 'user-service/**'
            task-service:
              - 'task-service/**'
            notification-service:
              - 'notification-service/**'
            gateway:
              - 'gateway/**'
            file-service:
              - 'file-service/**'
            event-service:
              - 'event-service/**'
            attendee-service:
              - 'attendee-service/**'
            shared-modules:
              - 'framework/**'
              - 'common/**'
              - 'shared-api/**'
              - 'pom.xml'

      - name: Set all services list
        id: set-services
        run: |
          echo "all=[\"user-service\",\"task-service\",\"notification-service\",\"gateway\", \"file-service\", \"event-service\", \"attendee-service\"]" >> $GITHUB_OUTPUT

      - name: Determine affected services
        id: resolve
        run: |
          CHANGED='${{ steps.filter.outputs.changes }}'
          if [ "$CHANGED" = "[]" ] || [ -z "$CHANGED" ]; then
            echo "services=[]" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if echo "$CHANGED" | jq -e 'index("shared-modules")' >/dev/null; then
            echo "Shared module changed. Building all services."
            ALL_SERVICES='${{ steps.set-services.outputs.all }}'
            echo "services=$ALL_SERVICES" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if echo "$CHANGED" | jq empty 2>/dev/null; then
            echo "services=$CHANGED" >> "$GITHUB_OUTPUT"
          elif [ "$CHANGED" != "" ]; then
            json=$(printf '%s' "$CHANGED" | jq -Rsc 'gsub("\n";",") | split(",") | map(select(length>0)) | map(gsub("^\\s+|\\s+$";""))')
            echo "services=$json" >> "$GITHUB_OUTPUT"
          else
            echo "services=[]" >> "$GITHUB_OUTPUT"
          fi

  build-and-test:
    name: Build & JUnit & Lint- ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.services != '[]'
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: Clear cached Gatling plugin (task-service)
        if: ${{ matrix.service == 'task-service' }}
        run: rm -rf ~/.m2/repository/io/gatling/gatling-maven-plugin

      - name: Lint (Spotless + Checkstyle) for ${{ matrix.service }}
        run: mvn -B -pl ${{ matrix.service }} -am spotless:check checkstyle:check

      - name: Build & Run tests for ${{ matrix.service }}
        run: mvn -B -pl ${{ matrix.service }} -am clean verify

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.service }}-jar
          path: ./${{ matrix.service }}/target/*.jar
          retention-days: 1

  sca-sbom:
    name: SCA & SBOM - ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-test]
    if: needs.detect-changes.outputs.services != '[]'
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
      fail-fast: false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'

      - name: Build (skip tests) for ${{ matrix.service }}
        run: mvn -B -pl ${{ matrix.service }} -am clean package -DskipTests

      - name: Set report filenames
        run: |
          echo "SBOM_FILE=${{ matrix.service }}-sbom.cdx.json" >> $GITHUB_ENV
          echo "SARIF_REPORT=${{ matrix.service }}-grype-report.sarif" >> $GITHUB_ENV
          echo "TABLE_REPORT=${{ matrix.service }}-grype-report.txt" >> $GITHUB_ENV

      - name: Generate SBOM (CycloneDX JSON)
        uses: anchore/sbom-action@v0
        with:
          path: ./${{ matrix.service }}
          format: cyclonedx-json
          output-file: ${{ env.SBOM_FILE }}
          upload-artifact: false
          upload-release-assets: false

      - name: SCA via Anchore (SARIF)
        uses: anchore/scan-action@v6
        with:
          sbom: ${{ env.SBOM_FILE }}
          fail-build: false
          severity-cutoff: high
          only-fixed: true
          output-format: sarif
          output-file: ${{ env.SARIF_REPORT }}

      - name: SCA via Anchore (table)
        uses: anchore/scan-action@v6
        with:
          sbom: ${{ env.SBOM_FILE }}
          fail-build: false
          severity-cutoff: high
          only-fixed: true
          output-format: table
          output-file: ${{ env.TABLE_REPORT }}

      - name: Upload SBOM & SCA artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: sbom-and-sca-${{ matrix.service }}-${{ github.run_id }}-${{ github.run_attempt }}
          path: |
            ${{ env.SBOM_FILE }}
            ${{ env.SARIF_REPORT }}
            ${{ env.TABLE_REPORT }}
          retention-days: 5

  sonar-scan:
    name: Sonar Scan
    runs-on: ubuntu-latest
    needs: detect-changes
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: 'temurin'

      - name: Cache SonarQube packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Cache Maven packages
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
          restore-keys: ${{ runner.os }}-m2

      - name: SonarCloud Scan
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_ORGANIZATION: ${{ secrets.SONAR_ORGANIZATION }}
          SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
        run: |
          mvn -B clean verify org.sonarsource.scanner.maven:sonar-maven-plugin:sonar \
            -Dsonar.host.url=https://sonarcloud.io \
            -Dsonar.organization="${SONAR_ORGANIZATION}" \
            -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
            -Dsonar.exclusions="common/**/*,framework/**/*,notification-service/**/*,wsgateway/**/*" \
            -Dsonar.coverage.exclusions="common/**/*,framework/**/*,notification-service/**/*,wsgateway/**/*"

  build-and-push-docker:
    name: Docker Build & Push - ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-test]
    if: |
      needs.detect-changes.outputs.services != '[]' && 
      (github.ref == 'refs/heads/main')
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
    steps:
      - uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.service }}-jar
          path: ./${{ matrix.service }}/target

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=semver,pattern={{version}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ matrix.service }}
          file: ./${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.service }}:buildcache
          cache-to: type=registry,ref=${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.service }}:buildcache,mode=max

  deploy-to-gke:
    name: Deploy to GKE - ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-push-docker]
    if: |
      needs.detect-changes.outputs.services != '[]' &&
      (github.ref == 'refs/heads/main') && vars.USE_GKE == 'true'
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services) }}
    steps:
      - uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: 'gke-gcloud-auth-plugin'

      - name: Configure kubectl plugin
        run: |
          echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ secrets.GKE_CLUSTER_NAME }} \
            --region=${{ env.GCP_REGION }} \
            --project=${{ secrets.GCP_PROJECT_ID }}

      - name: Verify kubectl connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Ensure namespace exists
        run: |
          kubectl apply -f k8s/namespace.yaml

      - name: Prepare Kubernetes manifests
        run: |
          IMAGE_TAG="${{ github.ref_name }}-${{ github.sha }}"
          IMAGE="${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.service }}:$IMAGE_TAG"

          if [ ! -f "k8s/${{ matrix.service }}/deployment.yaml" ]; then
          echo "Kubernetes manifest not found: k8s/${{ matrix.service }}/deployment.yaml"
          echo "Falling back to kubectl set image..."
          echo "USE_MANIFEST=false" >> $GITHUB_ENV
          else
          echo "Kubernetes manifest found"
          echo "USE_MANIFEST=true" >> $GITHUB_ENV
          
          mkdir -p /tmp/k8s/${{ matrix.service }}
          
          cp k8s/${{ matrix.service }}/*.yaml /tmp/k8s/${{ matrix.service }}/
          sed -i "s|DOCKER_HUB_USERNAME/${{ matrix.service }}:latest|$IMAGE|g" /tmp/k8s/${{ matrix.service }}/deployment.yaml
          fi

      - name: Deploy to GKE (using manifests)
        if: env.USE_MANIFEST == 'true'
        run: |
          kubectl apply -f /tmp/k8s/${{ matrix.service }}/ -n ${{ env.K8S_NAMESPACE }}
          
      - name: Deploy to GKE (using set image)
        if: env.USE_MANIFEST == 'false'
        run: |
          echo "Deploying ${{ matrix.service }} with kubectl set image..."
          IMAGE_TAG="${{ github.ref_name }}-${{ github.sha }}"
          IMAGE="${{ secrets.DOCKER_HUB_USERNAME }}/${{ matrix.service }}:$IMAGE_TAG"
          
          # Check whether the deployment exists
          if kubectl get deployment ${{ matrix.service }} -n ${{ env.K8S_NAMESPACE }} &> /dev/null; then
          echo "Updating existing deployment..."
          kubectl set image deployment/${{ matrix.service }} \
           ${{ matrix.service }}=$IMAGE \
           -n ${{ env.K8S_NAMESPACE }}
          else
          echo "Deployment not found. Please create manifests or manually create the deployment first."
          exit 1
          fi

      - name: Wait for rollout to complete
        run: |
          echo "Waiting for rollout to complete..."
          kubectl rollout status deployment/${{ matrix.service }} \
          -n ${{ env.K8S_NAMESPACE }} \
          --timeout=10m

      - name: Verify deployment
        run: |
          echo "Deployment status:"
          kubectl get deployment ${{ matrix.service }} -n ${{ env.K8S_NAMESPACE }}
          echo ""
          echo "Pod status:"
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=${{ matrix.service }}
          echo ""
          echo "Service info:"
          kubectl get service ${{ matrix.service }} -n ${{ env.K8S_NAMESPACE }} 2>/dev/null || echo "Service not configured"
          echo ""
          echo "Recent events:"
          kubectl get events -n ${{ env.K8S_NAMESPACE }} \
            --field-selector involvedObject.name=${{ matrix.service }} \
            --sort-by='.lastTimestamp' \
            | tail -30

  performance_test:
    name: Performance Test
    runs-on: ubuntu-latest
    needs: deploy-to-gke
    if: |
      github.ref == 'refs/heads/main' &&
      needs.deploy-to-gke.result == 'success'
    env:
      PERF_BASE_URL: ${{ secrets.TASK_SERVICE_PERF_BASE_URL }}
      PERF_EVENT_ID: ${{ secrets.TASK_SERVICE_PERF_EVENT_ID }}
      PERF_TASK_ID: ${{ secrets.TASK_SERVICE_PERF_TASK_ID }}
      PERF_USERNAME: ${{ secrets.TASK_SERVICE_PERF_USERNAME }}
      PERF_PASSWORD: ${{ secrets.TASK_SERVICE_PERF_PASSWORD }}
      PERF_LOGIN_PATH: ${{ secrets.TASK_SERVICE_PERF_LOGIN_PATH }}
    steps:
      - name: Validate performance secrets
        id: perf-check
        run: |
          if [ -z "${PERF_BASE_URL}" ]; then
            echo "Performance base URL secret is not set. Skipping Gatling job."
            echo "should-run=false" >> "$GITHUB_OUTPUT"
          else
            echo "should-run=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Skip summary
        if: ${{ steps.perf-check.outputs.should-run == 'false' }}
        run: echo "task-service performance job skipped because TASK_SERVICE_PERF_BASE_URL is empty."

      - uses: actions/checkout@v4
        if: ${{ steps.perf-check.outputs.should-run == 'true' }}

      - name: Add perf VM SSH key
        uses: webfactory/ssh-agent@v0.9.0
        if: ${{ steps.perf-check.outputs.should-run == 'true' }}
        with:
          ssh-private-key: ${{ secrets.PERF_VM_SSH_KEY }}

      - name: Trust perf VM host
        if: ${{ steps.perf-check.outputs.should-run == 'true' }}
        env:
          PERF_VM_HOST: ${{ secrets.PERF_VM_HOST }}
          PERF_VM_PORT: ${{ secrets.PERF_VM_SSH_PORT }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts
          PORT="${PERF_VM_PORT:-22}"
          ssh-keyscan -p "$PORT" "$PERF_VM_HOST" >> ~/.ssh/known_hosts

      - name: Deploy Gatling runner script to perf VM
        if: ${{ steps.perf-check.outputs.should-run == 'true' }}
        env:
          PERF_VM_HOST: ${{ secrets.PERF_VM_HOST }}
          PERF_VM_USER: ${{ secrets.PERF_VM_USER }}
          PERF_VM_PORT: ${{ secrets.PERF_VM_SSH_PORT }}
        run: |
          set -euo pipefail
          PORT="${PERF_VM_PORT:-22}"
          ssh -p "$PORT" "${PERF_VM_USER}@${PERF_VM_HOST}" "mkdir -p /opt/gatling"
          scp -P "$PORT" task-service/perf/run-gatling-vm.sh "${PERF_VM_USER}@${PERF_VM_HOST}:/opt/gatling/run-gatling.sh"
          ssh -p "$PORT" "${PERF_VM_USER}@${PERF_VM_HOST}" "chmod +x /opt/gatling/run-gatling.sh"

      - name: Run Gatling on perf VM
        if: ${{ steps.perf-check.outputs.should-run == 'true' }}
        id: run-gatling
        env:
          PERF_VM_HOST: ${{ secrets.PERF_VM_HOST }}
          PERF_VM_USER: ${{ secrets.PERF_VM_USER }}
          PERF_VM_PORT: ${{ secrets.PERF_VM_SSH_PORT }}
          TASK_SERVICE_PERF_BASE_URL: ${{ secrets.TASK_SERVICE_PERF_BASE_URL }}
          TASK_SERVICE_PERF_LOGIN_PATH: ${{ secrets.TASK_SERVICE_PERF_LOGIN_PATH }}
          TASK_SERVICE_PERF_USERNAME: ${{ secrets.TASK_SERVICE_PERF_USERNAME }}
          TASK_SERVICE_PERF_PASSWORD: ${{ secrets.TASK_SERVICE_PERF_PASSWORD }}
          TASK_SERVICE_PERF_EVENT_ID: ${{ secrets.TASK_SERVICE_PERF_EVENT_ID }}
          TASK_SERVICE_PERF_TASK_ID: ${{ secrets.TASK_SERVICE_PERF_TASK_ID }}
          TASK_SERVICE_RESULTS_UPLOAD_URL: ${{ secrets.TASK_SERVICE_RESULTS_UPLOAD_URL }}
          TASK_SERVICE_RESULTS_OBJECT: ${{ secrets.TASK_SERVICE_RESULTS_OBJECT }}
          PERF_VM_GIT_CLONE_URL: ${{ secrets.PERF_VM_GIT_CLONE_URL }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
        run: |
          set -euo pipefail
          PORT="${PERF_VM_PORT:-22}"
          esc() {
            printf "%s" "$1" | sed "s/'/'\"'\"'/g"
          }
          remote_cmd="TASK_SERVICE_BASE_URL='$(esc "$TASK_SERVICE_PERF_BASE_URL")'"
          if [[ -n "${TASK_SERVICE_PERF_LOGIN_PATH:-}" ]]; then
            remote_cmd+=" TASK_SERVICE_LOGIN_PATH='$(esc "$TASK_SERVICE_PERF_LOGIN_PATH")'"
          fi
          if [[ -n "${TASK_SERVICE_PERF_USERNAME:-}" ]]; then
            remote_cmd+=" TASK_SERVICE_USERNAME='$(esc "$TASK_SERVICE_PERF_USERNAME")'"
          fi
          if [[ -n "${TASK_SERVICE_PERF_PASSWORD:-}" ]]; then
            remote_cmd+=" TASK_SERVICE_PASSWORD='$(esc "$TASK_SERVICE_PERF_PASSWORD")'"
          fi
          if [[ -n "${TASK_SERVICE_PERF_EVENT_ID:-}" ]]; then
            remote_cmd+=" TASK_SERVICE_EVENT_ID='$(esc "$TASK_SERVICE_PERF_EVENT_ID")'"
          fi
          if [[ -n "${TASK_SERVICE_PERF_TASK_ID:-}" ]]; then
            remote_cmd+=" TASK_SERVICE_TASK_ID='$(esc "$TASK_SERVICE_PERF_TASK_ID")'"
          fi
          if [[ -n "${TASK_SERVICE_RESULTS_UPLOAD_URL:-}" ]]; then
            remote_cmd+=" TASK_SERVICE_RESULTS_UPLOAD_URL='$(esc "$TASK_SERVICE_RESULTS_UPLOAD_URL")'"
          fi
          if [[ -n "${TASK_SERVICE_RESULTS_OBJECT:-}" ]]; then
            remote_cmd+=" TASK_SERVICE_RESULTS_OBJECT='$(esc "$TASK_SERVICE_RESULTS_OBJECT")'"
          fi
          if [[ -n "${PERF_VM_GIT_CLONE_URL:-}" ]]; then
            remote_cmd+=" GIT_CLONE_URL='$(esc "$PERF_VM_GIT_CLONE_URL")'"
          fi
          if [[ -n "${GITHUB_REF_NAME:-}" ]]; then
            remote_cmd+=" GIT_REF='$(esc "$GITHUB_REF_NAME")'"
          fi
          remote_cmd+=" /opt/gatling/run-gatling.sh"
          ssh -p "$PORT" "${PERF_VM_USER}@${PERF_VM_HOST}" "$remote_cmd"

      - name: Copy Gatling report from perf VM
        if: ${{ always() && steps.perf-check.outputs.should-run == 'true' }}
        id: fetch-report
        env:
          PERF_VM_HOST: ${{ secrets.PERF_VM_HOST }}
          PERF_VM_USER: ${{ secrets.PERF_VM_USER }}
          PERF_VM_PORT: ${{ secrets.PERF_VM_SSH_PORT }}
        run: |
          set -euo pipefail
          PORT="${PERF_VM_PORT:-22}"
          REMOTE_RESULTS_DIR="/opt/gatling/results"
          if ! LATEST=$(ssh -p "$PORT" "${PERF_VM_USER}@${PERF_VM_HOST}" "cat ${REMOTE_RESULTS_DIR}/latest.txt" 2>/dev/null); then
            echo "No Gatling report available on perf VM."
            exit 0
          fi
          scp -P "$PORT" "${PERF_VM_USER}@${PERF_VM_HOST}:${REMOTE_RESULTS_DIR}/${LATEST}" gatling-report.tgz
          echo "report=gatling-report.tgz" >> "$GITHUB_OUTPUT"

      - name: Upload Gatling report
        if: ${{ always() && steps.perf-check.outputs.should-run == 'true' && steps.fetch-report.outputs.report != '' }}
        uses: actions/upload-artifact@v4
        with:
          name: task-service-gatling-${{ github.run_id }}-${{ github.run_attempt }}
          path: gatling-report.tgz
          retention-days: 3

  dast-zap:
    name: DAST (ZAP full scan)
    runs-on: ubuntu-latest
    needs: deploy-to-gke
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Prepare target URL
        run: |
          TARGET_URL="${{ vars.BASE_URL }}"
          if [ -z "$TARGET_URL" ]; then
            echo "BASE_URL secret is not configured. Configure secrets.BASE_URL before running DAST." >&2
            exit 1
          fi
          CLEAN_URL="${TARGET_URL%/}"
          echo "NORMALIZED_URL=$CLEAN_URL" >> $GITHUB_ENV

      - name: ZAP full scan
        run: |
          set +e
          mkdir -p "${GITHUB_WORKSPACE}/zap-reports"
          docker pull ghcr.io/zaproxy/zaproxy:stable -q
          docker run --rm \
            -v "${GITHUB_WORKSPACE}/zap-reports:/zap/wrk:rw" \
            ghcr.io/zaproxy/zaproxy:stable \
            zap-full-scan.py \
              -t "$NORMALIZED_URL" \
              -j zap-report.json \
              -x zap-report.xml \
              -r zap-report.html \
              -P 1001 \
              -m 5
          ZAP_EXIT=$?
          echo "ZAP_EXIT=${ZAP_EXIT}"

          if [ "$ZAP_EXIT" -ne 0 ] && [ "$ZAP_EXIT" -ne 2 ]; then
            exit "$ZAP_EXIT"
          fi

          echo "ZAP outputs in ${GITHUB_WORKSPACE}/zap-reports:"
          ls -la "${GITHUB_WORKSPACE}/zap-reports" || true

      - name: Upload ZAP reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-dast-reports-${{ github.run_id }}-${{ github.run_attempt }}
          path: ${{ github.workspace }}/zap-reports
          retention-days: 5
